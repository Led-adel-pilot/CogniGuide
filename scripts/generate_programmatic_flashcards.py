#!/usr/bin/env python3
"""Generate Programmatic Flashcard landing pages from a CSV via the OpenAI SDK.

This script reads a CSV of page definitions, prompts a Gemini-capable OpenAI model
for rich SEO copy, and emits TypeScript objects that satisfy the
``ProgrammaticFlashcardPage`` schema. Run it locally before committing the resulting
TypeScript so that every generated page can be statically rendered by Next.js.

Example usage::

    python scripts/generate_programmatic_flashcards.py \
        --input data/flashcard_pages.csv \
        --output lib/programmatic/generated/flashcardPages.ts \
        --model gemini-2.5-flash-lite \
        --temperature 2.0

The input CSV must include, at minimum, the columns ``slug`` and ``topic``. Every
other column becomes context that is injected into the LLM prompt so you can steer
copy for different audiences, intents, CTAs, etc.
"""

from __future__ import annotations

import argparse
import csv
import json
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Mapping

from openai import OpenAI

DEFAULT_MODEL = "gemini-flash-lite-latest"
DEFAULT_TEMPERATURE = 2.0
OUTPUT_HEADER = """// This file is autogenerated by scripts/generate_programmatic_flashcards.py
// Do not edit by hand — update the CSV and rerun the generator.

import type { ProgrammaticFlashcardPage } from '@/lib/programmatic/flashcardPageSchema';

export const generatedFlashcardPages: ProgrammaticFlashcardPage[] = [
"""
OUTPUT_FOOTER = "];\n"

PROMPT_TEMPLATE = """
You are an SEO strategist and senior copywriter helping an AI study assistant
launch programmatic landing pages.

You will receive structured CSV data describing one page to generate. Follow
these requirements:

1. Write unique, high-utility copy that aligns with the provided topic and intent.
2. Mirror the structure of the ProgrammaticFlashcardPage schema:
   - hero.heading (focus keyword up front), hero.subheading, CTA labels.
   - featuresSection (3+ feature cards with differentiated benefits).
   - howItWorksSection with exactly 3 sequential steps customised to the topic.
   - seoSection with a mix of paragraphs and bullet lists that reinforce topical
     authority and internal links opportunities. Use HTML tags for emphasis and links.
   - faqSection with 4 distinct questions tailored to the topic. Provide concise,
     helpful answers grounded in the product capabilities.
   - relatedTopicsSection with at least 2 internal links (hrefs supplied in CSV or
     sensible defaults such as /ai-mind-map-generator, /pricing).
   - metadata fields (title, description, keywords array, canonical path) optimised
     for long-tail search queries.
3. Ensure every text block demonstrates E-E-A-T principles, includes concrete
   benefits, and avoids duplicate phrasing across pages.
4. All output MUST be valid JSON following this structure:

{
  "slug": string,
  "path": string,
  "metadata": {
    "title": string,
    "description": string,
    "keywords": string[],
    "canonical": string
  },
  "hero": {
    "heading": string,
    "subheading": string,
    "supportingText": string,
    "primaryCta": { "type": "modal", "label": string },
    "secondaryCta": { "type": "link", "label": string, "href": string } | null
  },
  "featuresSection": {
    "heading": string,
    "subheading": string,
    "features": [{ "title": string, "description": string }, ...]
  },
  "howItWorksSection": {
    "heading": string,
    "subheading": string,
    "steps": [{ "title": string, "description": string }, ...],
    "cta": { "type": "link", "label": string, "href": string } | { "type": "modal", "label": string }
  },
  "seoSection": {
    "heading": string,
    "body": [
      { "type": "paragraph", "html": string } |
      { "type": "list", "items": string[] }
    ]
  },
  "faqSection": {
    "heading": string,
    "subheading": string,
    "items": [{ "question": string, "answer": string }, ...],
    "cta": { "type": "modal", "label": string }
  },
  "relatedTopicsSection": {
    "heading": string,
    "links": [{ "label": string, "href": string, "description": string }, ...]
  }
}

5. Each HTML string must be safe to embed inside JSX without additional escaping.
6. Reuse the provided "base_url" column to create canonical URLs. If none is
   provided, default to https://www.cogniguide.app.
7. Keep language clear, professional, and benefit-driven. No placeholder text.
8. IMPORTANT: For CTA objects:
   - Modal CTAs should ONLY have: {"type": "modal", "label": string}
   - Link CTAs should ONLY have: {"type": "link", "label": string, "href": string}
   - Never include "href" in modal CTAs or vice versa.

Return ONLY the JSON object. Do not wrap the response in markdown.
"""


def parse_args(argv: Iterable[str] | None = None) -> argparse.Namespace:
  parser = argparse.ArgumentParser(description="Generate programmatic flashcard pages")
  parser.add_argument("--input", required=True, help="Path to the CSV containing page definitions")
  parser.add_argument(
    "--output",
    default="lib/programmatic/generated/flashcardPages.ts",
    help="Destination TypeScript file to overwrite",
  )
  parser.add_argument(
    "--model",
    default=DEFAULT_MODEL,
    help="OpenAI model name (Gemini-compatible models supported via the OpenAI SDK)",
  )
  parser.add_argument(
    "--temperature",
    type=float,
    default=DEFAULT_TEMPERATURE,
    help="Sampling temperature for creative variation",
  )
  parser.add_argument(
    "--max-rows",
    type=int,
    default=None,
    help="Optional maximum number of rows to process (for testing)",
  )
  parser.add_argument(
    "--api-key",
    default=None,
    help="Explicit Gemini API key. Falls back to the GEMINI_API_KEY env var if omitted.",
  )
  return parser.parse_args(argv)


@dataclass
class CsvRow:
  slug: str
  data: Mapping[str, str]

  @property
  def path(self) -> str:
    return self.data.get("path") or f"/flashcards/{self.slug}"

  @property
  def base_url(self) -> str:
    return self.data.get("base_url") or "https://www.cogniguide.app"

  def prompt_payload(self) -> str:
    payload = {
      "slug": self.slug,
      "path": self.path,
      "base_url": self.base_url,
      "context": {k: v for k, v in self.data.items() if k not in {"slug", "path", "base_url"}},
    }
    return json.dumps(payload, ensure_ascii=False, indent=2)


def read_csv_rows(path: Path, max_rows: int | None = None) -> List[CsvRow]:
  with path.open(newline="", encoding="utf-8") as handle:
    reader = csv.DictReader(handle)
    if "slug" not in reader.fieldnames:
      raise ValueError("Input CSV must include a 'slug' column")

    rows: List[CsvRow] = []
    for idx, raw in enumerate(reader):
      if max_rows is not None and idx >= max_rows:
        break
      slug = (raw.get("slug") or "").strip()
      if not slug:
        raise ValueError(f"Row {idx + 2} is missing a slug")
      rows.append(CsvRow(slug=slug, data={k: (v or '').strip() for k, v in raw.items()}))
    return rows


def call_model(
  client: OpenAI,
  model: str,
  temperature: float,
  payload: str,
) -> Dict[str, Any]:
  response = client.chat.completions.create(
    model=model,
    temperature=temperature,
    messages=[
      {
        "role": "system",
        "content": PROMPT_TEMPLATE,
      },
      {
        "role": "user",
        "content": f"CSV row JSON:\n{payload}",
      },
    ],
    response_format={
      "type": "json_schema",
      "json_schema": {
        "name": "programmatic_flashcard_page",
        "schema": {
          "type": "object",
          "properties": {
            "slug": {"type": "string"},
            "path": {"type": "string"},
            "metadata": {"type": "object"},
            "hero": {"type": "object"},
            "featuresSection": {"type": "object"},
            "howItWorksSection": {"type": "object"},
            "seoSection": {"type": "object"},
            "faqSection": {"type": "object"},
            "relatedTopicsSection": {"type": "object"},
          },
          "required": [
            "slug",
            "path",
            "metadata",
            "hero",
            "featuresSection",
            "howItWorksSection",
            "seoSection",
            "faqSection",
            "relatedTopicsSection",
          ],
          "additionalProperties": True,
        },
      },
    },
  )

  if not response.choices or not response.choices[0].message.content:
    raise RuntimeError("Model returned an empty response")

  return json.loads(response.choices[0].message.content)


def normalise_page(row: CsvRow, payload: Dict[str, Any]) -> Dict[str, Any]:
  canonical = payload.get("metadata", {}).get("canonical")
  if not canonical:
    canonical = f"{row.base_url.rstrip('/')}{row.path}"
    payload.setdefault("metadata", {})["canonical"] = canonical

  payload.setdefault("path", row.path)
  payload.setdefault("slug", row.slug)
  # Remove structuredData if not provided by the model
  if payload.get("structuredData") is None:
    payload.pop("structuredData", None)
  return payload


def serialize_pages(pages: List[Dict[str, Any]]) -> str:
  body = ",\n".join(
    "  " + json.dumps(page, ensure_ascii=False, indent=2)
    .replace("\n", "\n  ")
    .replace("\\u2019", "’")
    for page in pages
  )
  return f"{OUTPUT_HEADER}{body}\n{OUTPUT_FOOTER}"


def main(argv: Iterable[str] | None = None) -> int:
  args = parse_args(argv)
  input_path = Path(args.input)
  output_path = Path(args.output)

  rows = read_csv_rows(input_path, max_rows=args.max_rows)
  if not rows:
    print("No rows found in input CSV", file=sys.stderr)
    return 1

  client = OpenAI(
    api_key=args.api_key or "GEMINI_API_KEY",  # Use placeholder as per custom instructions
    base_url="https://generativelanguage.googleapis.com/v1beta/openai/"
  )
  generated_pages: List[Dict[str, Any]] = []

  for row in rows:
    payload = call_model(client, args.model, args.temperature, row.prompt_payload())
    generated_pages.append(normalise_page(row, payload))

  output_path.parent.mkdir(parents=True, exist_ok=True)
  output_path.write_text(serialize_pages(generated_pages), encoding="utf-8")
  print(f"Wrote {len(generated_pages)} programmatic pages to {output_path}")
  return 0


if __name__ == "__main__":
  raise SystemExit(main())
