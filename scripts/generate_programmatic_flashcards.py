#!/usr/bin/env python3
"""Generate Programmatic Flashcard landing pages from a CSV via the OpenAI SDK.

This script reads a CSV of page definitions, prompts a Gemini-capable OpenAI model
for rich SEO copy, and emits TypeScript objects that satisfy the
``ProgrammaticFlashcardPage`` schema. Run it locally before committing the resulting
TypeScript so that every generated page can be statically rendered by Next.js.

Example usage::

    python scripts/generate_programmatic_flashcards.py \
        --input data/flashcard_pages.csv \
        --output lib/programmatic/generated/flashcardPages.ts \
        --model gemini-2.5-flash-lite \
        --temperature 2.0

The input CSV must include, at minimum, the columns ``slug`` and ``topic``. Every
other column becomes context that is injected into the LLM prompt so you can steer
copy for different audiences, intents, CTAs, etc.
"""

from __future__ import annotations

import argparse
import csv
import json
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Mapping

from openai import OpenAI

DEFAULT_MODEL = "gemini-flash-lite-latest"
DEFAULT_TEMPERATURE = 2.0
OUTPUT_HEADER = """// This file is autogenerated by scripts/generate_programmatic_flashcards.py
// Do not edit by hand — update the CSV and rerun the generator.

import type { ProgrammaticFlashcardPage } from '@/lib/programmatic/flashcardPageSchema';

export const generatedFlashcardPages: ProgrammaticFlashcardPage[] = [
"""
OUTPUT_FOOTER = "];\n"

PROMPT_TEMPLATE = """
You are an expert content strategist and senior copywriter specializing in high-ranking, user-focused SEO for EdTech SaaS companies. Your goal is to generate comprehensive, E-E-A-T compliant landing pages that rank for long-tail keywords and convert users for a new AI study assistant.

You will receive structured CSV data for one landing page. Follow these requirements precisely:

1.  **Write "People-First" Content:** Your primary goal is to create helpful, reliable, and original content that satisfies user search intent. The copy must be in-depth and high-utility. Avoid thin, boilerplate, or repetitive text. Each page must be unique and valuable.

2.  **Demonstrate E-E-A-T (Experience, Expertise, Authoritativeness, Trust):**
    * **Tone:** Write in a confident, informative, and trustworthy tone, as if from an expert in educational technology.
    * **Experience:** Show, don't just tell. Include specific benefits, use-cases, or hypothetical results (e.g., "...helped students cut study time in half" or "...improves exam scores by 20%").
    * **Expertise:** Weave in semantically related keywords and concepts naturally (e.g., "spaced repetition," "learning algorithms," "smarter studying," "cognitive science") to build topical authority.

3.  **Optimize On-Page SEO Elements:**
    * **Headings:** The `hero.heading` should be a unique, keyword-rich H1 that targets a specific long-tail query based on the topic. Use a logical hierarchy of H2s and H3s for section headings (`featuresSection.heading`, `faqSection.heading`, etc.) to improve readability and structure.
    * **Metadata:** The `metadata.title` should be compelling and keyword-focused. The `metadata.description` must be an engaging summary that encourages clicks from the SERP.
    * **SEO Section:** The `seoSection` must be substantial, offering detailed information, examples, and use cases. This is a critical area for building topical authority and should contain a mix of paragraphs and lists. Weave in contextual internal links to other relevant pages.

4.  **Drive Conversions:**
    * **CTAs:** All CTA labels must be clear, action-oriented, and benefit-driven (e.g., "Create My Flashcards Now" instead of "Submit").
    * **Trust:** The UI already displays "No credit card required" beneath the hero CTA, so you do not need to generate additional supporting text there. Instead, focus on trustworthy tone throughout the copy.

5.  **Strictly Adhere to JSON Output:** Your entire output MUST be a single, valid JSON object that follows the structure below. Do not wrap it in markdown.

{
  "slug": string,
  "path": string,
  "metadata": {
    "title": string, // SEO-optimized, <60 chars
    "description": string, // Meta description, ~155 chars
    "keywords": string[],
    "canonical": string
  },
  "hero": {
    "heading": string, // The H1 tag, primary long-tail keyword
    "subheading": string,
    "primaryCta": { "type": "modal", "label": string },
  },
  "featuresSection": {
    "heading": string, // H2 heading
    "subheading": string,
    "features": [{ "title": string, "description": string }, ...] // At least 3 features
  },
  "howItWorksSection": {
    "heading": string, // H2 heading
    "subheading": string,
    "steps": [{ "title": string, "description": string }, ...], // Exactly 3 steps
    "cta": { "type": "link", "label": string, "href": string } | { "type": "modal", "label": string }
  },
  "seoSection": {
    "heading": string, // H2 heading
    "body": [ // In-depth, helpful content
      { "type": "paragraph", "html": string } |
      { "type": "list", "items": string[] }
    ]
  },
  "faqSection": {
    "heading": string, // H2 heading
    "subheading": string,
    "items": [{ "question": string, "answer": string }, ...], // 4 distinct, relevant questions
    "cta": { "type": "modal", "label": string }
  },
  "relatedTopicsSection": {
    "heading": string, // H2 heading
    "links": [{ "label": string, "href": string, "description": string }, ...] // At least 2 internal links
  },
  "structuredData": { // Optional: Include FAQPage schema if relevant
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": string, // from faqSection
          "acceptedAnswer": {
            "@type": "Answer",
            "text": string // from faqSection
          }
        }
      ]
    }
}

6.  **Final Checks:**
    * Use the provided "base_url" for canonical URLs. Default to https://www.cogniguide.app if not provided.
    * Ensure all HTML strings are safe for JSX.
    * No placeholder text. All fields must be complete and production-ready.

Return ONLY the JSON object.
"""


def parse_args(argv: Iterable[str] | None = None) -> argparse.Namespace:
  parser = argparse.ArgumentParser(description="Generate programmatic flashcard pages")
  parser.add_argument("--input", required=True, help="Path to the CSV containing page definitions")
  parser.add_argument(
    "--output",
    default="lib/programmatic/generated/flashcardPages.ts",
    help="Destination TypeScript file to overwrite",
  )
  parser.add_argument(
    "--model",
    default=DEFAULT_MODEL,
    help="OpenAI model name (Gemini-compatible models supported via the OpenAI SDK)",
  )
  parser.add_argument(
    "--temperature",
    type=float,
    default=DEFAULT_TEMPERATURE,
    help="Sampling temperature for creative variation",
  )
  parser.add_argument(
    "--max-rows",
    type=int,
    default=None,
    help="Optional maximum number of rows to process (for testing)",
  )
  parser.add_argument(
    "--api-key",
    default=None,
    help="Explicit Gemini API key. Falls back to the GEMINI_API_KEY env var if omitted.",
  )
  return parser.parse_args(argv)


@dataclass
class CsvRow:
  slug: str
  data: Mapping[str, str]

  @property
  def path(self) -> str:
    return self.data.get("path") or f"/flashcards/{self.slug}"

  @property
  def base_url(self) -> str:
    return self.data.get("base_url") or "https://www.cogniguide.app"

  def prompt_payload(self) -> str:
    payload = {
      "slug": self.slug,
      "path": self.path,
      "base_url": self.base_url,
      "context": {k: v for k, v in self.data.items() if k not in {"slug", "path", "base_url"}},
    }
    return json.dumps(payload, ensure_ascii=False, indent=2)


def read_csv_rows(path: Path, max_rows: int | None = None) -> List[CsvRow]:
  with path.open(newline="", encoding="utf-8") as handle:
    reader = csv.DictReader(handle)
    if "slug" not in reader.fieldnames:
      raise ValueError("Input CSV must include a 'slug' column")

    rows: List[CsvRow] = []
    for idx, raw in enumerate(reader):
      if max_rows is not None and idx >= max_rows:
        break
      slug = (raw.get("slug") or "").strip()
      if not slug:
        raise ValueError(f"Row {idx + 2} is missing a slug")
      rows.append(CsvRow(slug=slug, data={k: (v or '').strip() for k, v in raw.items()}))
    return rows


def call_model(
  client: OpenAI,
  model: str,
  temperature: float,
  payload: str,
) -> Dict[str, Any]:
  response = client.chat.completions.create(
    model=model,
    temperature=temperature,
    messages=[
      {
        "role": "system",
        "content": PROMPT_TEMPLATE,
      },
      {
        "role": "user",
        "content": f"CSV row JSON:\n{payload}",
      },
    ],
    response_format={
      "type": "json_schema",
      "json_schema": {
        "name": "programmatic_flashcard_page",
        "schema": {
          "type": "object",
          "properties": {
            "slug": {"type": "string"},
            "path": {"type": "string"},
            "metadata": {"type": "object"},
            "hero": {"type": "object"},
            "featuresSection": {"type": "object"},
            "howItWorksSection": {"type": "object"},
            "seoSection": {"type": "object"},
            "faqSection": {"type": "object"},
            "relatedTopicsSection": {"type": "object"},
          },
          "required": [
            "slug",
            "path",
            "metadata",
            "hero",
            "featuresSection",
            "howItWorksSection",
            "seoSection",
            "faqSection",
            "relatedTopicsSection",
          ],
          "additionalProperties": True,
        },
      },
    },
  )

  if not response.choices or not response.choices[0].message.content:
    raise RuntimeError("Model returned an empty response")

  return json.loads(response.choices[0].message.content)


def normalise_page(row: CsvRow, payload: Dict[str, Any]) -> Dict[str, Any]:
  canonical = payload.get("metadata", {}).get("canonical")
  if not canonical:
    canonical = f"{row.base_url.rstrip('/')}{row.path}"
    payload.setdefault("metadata", {})["canonical"] = canonical

  payload.setdefault("path", row.path)
  payload.setdefault("slug", row.slug)
  # Remove structuredData if not provided by the model
  if payload.get("structuredData") is None:
    payload.pop("structuredData", None)
  return payload


def serialize_pages(pages: List[Dict[str, Any]]) -> str:
  body = ",\n".join(
    "  " + json.dumps(page, ensure_ascii=False, indent=2)
    .replace("\n", "\n  ")
    .replace("\\u2019", "’")
    for page in pages
  )
  return f"{OUTPUT_HEADER}{body}\n{OUTPUT_FOOTER}"


def main(argv: Iterable[str] | None = None) -> int:
  args = parse_args(argv)
  input_path = Path(args.input)
  output_path = Path(args.output)

  rows = read_csv_rows(input_path, max_rows=args.max_rows)
  if not rows:
    print("No rows found in input CSV", file=sys.stderr)
    return 1

  client = OpenAI(
    api_key=args.api_key or "GEMINI_API_KEY",  # Use placeholder as per custom instructions
    base_url="https://generativelanguage.googleapis.com/v1beta/openai/"
  )
  generated_pages: List[Dict[str, Any]] = []

  for row in rows:
    payload = call_model(client, args.model, args.temperature, row.prompt_payload())
    generated_pages.append(normalise_page(row, payload))

  output_path.parent.mkdir(parents=True, exist_ok=True)
  output_path.write_text(serialize_pages(generated_pages), encoding="utf-8")
  print(f"Wrote {len(generated_pages)} programmatic pages to {output_path}")
  return 0


if __name__ == "__main__":
  raise SystemExit(main())
